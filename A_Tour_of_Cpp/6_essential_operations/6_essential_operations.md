# Essential Operations

## Introduction
- Some operations such as initialization, assignment, copy, and move are fundamental (i.e., language rules make assumptions about them)
- Essential Operations
    - The Full Set
    ```cpp
    class X {
        public:
            X(Sometype); // ordinary cstr
            X(); // default cstr
            X(const X&); // cp cstr
            X(X&&); // mv cstr
            X& operator=(const X&); // cp assigment. clean up target and copy
            X& operator=(X&&); // mv assignment. clean up target and move
            ~X(); // destructor
    }
    ```
    - These special member functions will be automatically generated by the compiler as needed
    - `=default`
        - Use this to be explicit about generating default implementations
            - If you do this, other default definitions will not be generated
    - `=delete`
        - Use this to indicate that an operation is not to be generated
            - A base class might not want to allow a copy so using `=delete` on cp cstr and assignment makes sense.
    - Define all essential operations or none!
- Conversions
    - A constructor taking a single argument defines a conversion from its argument type
    ```cpp
    Vector v1 = 7; // ok. v1 with 7 items
    ```
    - This is not good. Use `explicit` to indicate that no implicit conversion is allowed
    ```cpp
    // in Vector 
    explicit Vector(int s);
    // ...
    Vector v1(7); // ok
    Vector v2 = 7; // no! no implicit conversion allowed
    ```
- Member Initializer
    - When defining data members, you can provide __default member initializer__. This value is used whenever a constructor doesn't provide a value.

## Copy and Move
- There are 5 situations where objects can be copied or moved
    - As the source of an assignment (cp/mv assignment operator)
    - As an object initializer (cp/mv cstr)
    - As a function argument (cp/mv cstr)
    - As a function return value (cp/mv cstr)
    - As an exception (cp/mv cstr)
- Default Copy
    - Member-wise copy
- When a class is a _resource handle_(that is, when it is responsible for an object accessed through a pointer) the default copy behavior is not what you want.
- Copy
    - Defined by two members: a _copy constructor_ and _copy assignment_.
    ```cpp
    // Copy Constructor
    Vector::Vector(const Vector& a) : elem{new double[a.sz]}, sz{a.sz}
    {
        for (int i = 0; i!=sz; ++i)
            elem[i] = a.elem[i]; // copy elements
    }
    // Copy Assignment
    Vector& Vector::operator=(const Vector& a) 
    {
        double* p = new double[a.sz];
        for (int i = 0; i!=sz; ++i)
            p[i] = a.elem[i]; // copy elements
        delete[] elem; // delete old ones
        elem = p;
        sz = a.sz;
        return *this; // this points to the object for which the member function is called
    }
    ```
- Move
    - How can we return a value without creating a copy? It could become costly for large containers!
    ```cpp
    // Move Constructor
    Vector::Vector(Vector&& a) : elem{new double[a.sz]}, sz{a.sz} // grab everything from a
    {
        // make sure to set a to empty (everything is moved!)
        a.elem = nullptr;
        a.sz = 0;
    }
    ```
    - && means __rvalue reference__.
        - It is a reference to a rvalue (such as an integer returned by a function call)
        - Reference to a value that nobody else can assign to <=> safe to steal its values!
    - We can be explicit by using `std::move`. 
        - It returns an rvalue reference (kind of like a cast!)
        ```cpp
        y = std::move(x); // mv assignment can be used now
        ```

## Resource Management
- Let each resource have an owner in some scope and by default be released at the end of its owner's scope.

## Operator Overloading
- Allows User-Defined Types to have its own meanings for different operators
    - This is called __operator overloading__
- An operator can be defined either as a member function or free standing functions
    - Member function way
        ```cpp
        Matrix& operator=(const Matrix& a);
        ```
        - Conventionally done for operators that modify their first operand
        - For `=`, `->`, `()`, and `[]`, the use of member function is required 
    - Free-standing way
        ```cpp
        Matrix operator+(const Matrix& a, const Matrix& b);
        ```
        - Conventionally used for operators with symmetric operands